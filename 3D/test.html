
<!DOCTYPE html>
<html style='width:100%; height:100%; border:0; margin:0; padding:0;'>
  
    <head>
        <title>three.js webgl - interactive - voxel painter</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"/>
        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }

            #oldie { background-color: #ddd !important }
        </style>
    </head>        

    <body>
        <!--<div class="container" ng-controller="ResetCtrl">
            <div class="row">
                <div class="col-md-2">
                    <p>
                        List of changes
                    </p>
                    <ul style="list-style-type:circle">
                        <li>Change1</li>
                        <li>Change2</li>
                        <li>Change3</li>
                    </ul>
                </div>-->

                <div id="3d">
                </div>
        
               <!-- <div class="col-sm-1">
                    <p>
                        List of docs
                    </p>
                    <ul style="list-style-type:circle">
                        <li>Doc1</li>
                        <li>Doc2</li>
                        <li>Doc3</li>
                    </ul>
                </div>
            </div>
        </div>-->
        

        <script src="js/three/build/three.js"></script>
        <script src="js/three/build/js/controls/OrbitControls.js"></script>
        <script src="js/three/build/js/libs/stats.min.js"></script>
        <script src="js/three/build/js/geometries/TextGeometry.js"></script>
        <script src="js/three/build/js/utils/FontUtils.js"></script>

        <script src="js/three/build/js/fonts/gentilis_bold.typeface.js"></script>
        <script src="js/three/build/js/fonts/gentilis_regular.typeface.js"></script>
        <script src="js/three/build/js/fonts/optimer_bold.typeface.js"></script>
        <script src="js/three/build/js/fonts/optimer_regular.typeface.js"></script>
        <script src="js/three/build/js/fonts/helvetiker_bold.typeface.js"></script>
        <script src="js/three/build/js/fonts/helvetiker_regular.typeface.js"></script>
        <script src="js/three/build/js/fonts/droid/droid_sans_regular.typeface.js"></script>
        <script src="js/three/build/js/fonts/droid/droid_sans_bold.typeface.js"></script>
        <script src="js/three/build/js/fonts/droid/droid_serif_regular.typeface.js"></script>
        <script src="js/three/build/js/fonts/droid/droid_serif_bold.typeface.js"></script>

        <script>
            //start()
            function init() {

                // HTML DOC
                container = document.getElementById("3d");
                
                //document.body.appendChild( container );

                // create camera
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.y = 1000;
                //camera.lookAt( new THREE.Vector3() );

                // create scene and add globle light
                scene = new THREE.Scene();
                scene.add( new THREE.AmbientLight( 0x505050 ) );

                // create specific light
                var light = new THREE.SpotLight( 0xffffff, 1.5 );
                light.position.set( 0, 500, 2000 );
                light.castShadow = true;

                light.shadowCameraNear = 200;
                light.shadowCameraFar = camera.far;
                light.shadowCameraFov = 50;

                light.shadowBias = -0.00022;

                light.shadowMapWidth = 2048;
                light.shadowMapHeight = 2048;

                scene.add( light );

                // create a base
                var size = 500, step = 50;

                var base_geometry = new THREE.Geometry();

                for ( var i = - size; i <= size; i += step ) {

                    base_geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
                    base_geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

                    base_geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
                    base_geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

                }

                var base_material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

                var base_line = new THREE.LineSegments( base_geometry, base_material );
                scene.add( base_line );

                // Blocks
                var positions = [];
                
                
                for ( var i = 0, nextX = -size, nextZ = -size; i < 45; i ++ ) {
                    var group = new THREE.Group();

                    var block_length = Math.floor( Math.random() * 51 ) + 50;
                    var block_width = Math.floor( Math.random() * 51 ) + 50;
                    var block_height = 3;
                    var block = new THREE.BoxGeometry( block_length, block_height, block_width );
                    var block_material = new THREE.MeshLambertMaterial( { color: 0xffffff, overdraw: 0.5 } );

                    var block_cube = new THREE.Mesh( block, block_material  );

                    //cube.scale.y = Math.floor( Math.random() * 2 + 1 );

                    //cube.position.x = Math.floor( ( Math.random() * 1000 - 500 ) / 50 ) * 50 + 25;
                    //cube.position.y = 10;
                    //cube.position.z = Math.floor( ( Math.random() * 1000 - 500 ) / 50 ) * 50 + 25;
                    block_cube.position.x = block_length / 2 + nextX;
                    block_cube.position.y = block_height / 2;
                    block_cube.position.z = block_width / 2 + nextZ;
                    // group.position.x = block_length / 2 + nextX;
                    // group.position.y = 1.5;
                    // group.position.z = block_width / 2 + nextZ;
                    scene.add( group );
                    group.add( block_cube );
                    positions.push(block_cube.position);
                    //Text
                    var textGeo = new THREE.TextGeometry( text + " " +i, {

                        size: font_size,
                        height: font_height,
                        curveSegments: curveSegments,

                        font: font,
                        weight: weight,
                        style: style,

                        bevelThickness: bevelThickness,
                        bevelSize: bevelSize,
                        bevelEnabled: bevelEnabled,

                        material: 0,
                        extrudeMaterial: 1

                    });
                    //textGeo.computeBoundingBox();
                    //textGeo.computeVertexNormals();
                    material = new THREE.MeshFaceMaterial( [
                        new THREE.MeshPhongMaterial( { color: 0x00ff00, shading: THREE.FlatShading } ), // front
                        new THREE.MeshPhongMaterial( { color: 0x00ff00, shading: THREE.SmoothShading } ) // side
                    ] );
                    var textMesh = new THREE.Mesh( textGeo, material );

                    textMesh.position.x = nextX;
                    textMesh.position.y = font_height / 2;
                    textMesh.position.z = block_width + nextZ + font_size;
                    textMesh.rotation.x = - Math.PI / 2;
                    textMesh.rotation.y = 0;
                    group.add(textMesh);


                    console.log(i + ": " + nextX + ", " + nextZ);
                    if(nextX + block_length + 170 > size){
                        nextX = -size;
                        nextZ += 70 + block_width;
                    }
                    else{
                        nextX += 70 + block_length;
                    }

                    var num = Math.floor( Math.random() * 4) + 2;
                    var x = block_cube.position.x - block_length / 2;
                    var z = block_cube.position.z - block_width / 2;
                    // Building
                    for (var j = 0; j < num; j++) {  
                        console.log(j + ": " + x + ", " + z + ", " + block_length);
                        //var build_length = Math.floor( block_length / 5 );
                        //var build_width = Math.floor( block_width / 5 );
                        var build_height = Math.floor( Math.random() * 100 + 3);
                        var build = new THREE.BoxGeometry( 10, build_height, 10);
                        var build_material = new THREE.MeshLambertMaterial( { color: 0xff0000, overdraw: 0.5 } );
                        var build_cube = new THREE.Mesh( build, build_material  );

                        build_cube.position.x = 10 / 2 + x;
                        build_cube.position.y = build_height / 2 + block_height;
                        build_cube.position.z = 10 / 2 + z;
                        scene.add( build_cube );

                        if(x + 10 + 20 > block_cube.position.x + block_length / 2){
                            x = block_cube.position.x - block_length / 2;
                            z += 10 + 10;
                        }
                        else{
                            x += 10 + 10;
                        }

                    };


                }

                
                //group.position.y = 100;

                //scene.add( group );

                // line
                for (var i = 0; i < 20; i++) {
                    console.log("line");
                    var line_material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    var line_geometry = new THREE.Geometry();
                    var start = Math.floor( Math.random() * 45);
                    var end = Math.floor( Math.random() * 45);
                    while(end == start){
                        end = Math.floor( Math.random() * 45);
                    }
                    line_geometry.vertices.push(positions[start]);
                    line_geometry.vertices.push(positions[end]);
                    //line.geometry.vertices.push(new THREE.Vector3(-500, 20, 100));
                    var line = new THREE.Line(line_geometry, line_material);
                    scene.add(line);
                };

               
                // plane = new THREE.Mesh(
                //     new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
                //     new THREE.MeshBasicMaterial( { visible: false } )
                // );
                // scene.add( plane );

                // create renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xf0f0f0 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth , window.innerHeight );
                renderer.sortObjects = false;

                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFShadowMap;

                container.appendChild( renderer.domElement );

                // create view control
                controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                controls.target.set (0,10,0);


                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

                // add listener
                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onDocumentMouseMove( event ) {

                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;


                // find intersections

                raycaster.setFromCamera( mouse, camera );

                var intersects = raycaster.intersectObjects( scene.children ), material;

                if (intersects.length > 0) {
                    if (INTERSECTED != intersects[0].object) {
                        if (INTERSECTED){
                            material = INTERSECTED.material;
                            if(material.emissive){
                                material.emissive.setHex(INTERSECTED.currentHex);
                                scene.remove(rightline);
                                scene.remove(leftline);
                            }
                        }   
                        INTERSECTED = intersects[0].object;
                        material = INTERSECTED.material;
                        if(material.emissive){
                            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                            material.emissive.setHex(0xff00ff);

                            // to right
                            var right_line_geometry = new THREE.Geometry();
                            right_line_geometry .vertices.push(INTERSECTED.position);
                            right_line_geometry .vertices.push(new THREE.Vector3(1000, Math.random() * 500, 0));
                            //line.geometry.vertices.push(new THREE.Vector3(-500, 20, 100));
                            rightline = new THREE.Line(right_line_geometry, direct_line_material);
                            scene.add(rightline);

                            // to left
 
                            var left_line_geometry = new THREE.Geometry();
                            left_line_geometry.vertices.push(INTERSECTED.position);
                            left_line_geometry.vertices.push(new THREE.Vector3(-1000, Math.random() * 500, 0));
                            //line.geometry.vertices.push(new THREE.Vector3(-500, 20, 100));
                            leftline = new THREE.Line(left_line_geometry, direct_line_material);
                            scene.add(leftline);
                        }
                        console.log("length: " + intersects.length);
                        console.log(INTERSECTED.position);
                    }

                } else {

                    if (INTERSECTED){
                        material = INTERSECTED.material;

                        if(material.emissive){
                            material.emissive.setHex(INTERSECTED.currentHex);
                            scene.remove(rightline);
                            scene.remove(leftline);
                        }
                    }

                    INTERSECTED = null;

                }
            }


            //

            function animate() {

                requestAnimationFrame( animate );

                render();


            }

            function render() {

                controls.update();

                renderer.render( scene, camera );

            }
        </script>

        <script>
            // main()
            var container, stats;
            var camera, controls, scene, renderer;
            var objects = [], plane;

            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;


            var rightline;
            var leftline;
            var direct_line_material = new THREE.LineBasicMaterial({
                color: 0x000000
            });
            var group;
            var text = "C",

                font_height = 2,
                font_size = 15,

                curveSegments = 4,

                bevelThickness = 2,
                bevelSize = 1.5,
                bevelSegments = 3,
                bevelEnabled = true,

                font = "helvetiker", // helvetiker, optimer, gentilis, droid sans, droid serif
                weight = "bold", // normal bold
                style = "normal"; // normal italic


            init();
            animate();

        </script>

    </body>
 
</html>